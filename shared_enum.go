// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package gosu

import (
	"errors"
	"fmt"
)

const (
	// RankStatusGraveyard is a RankStatus of type Graveyard.
	RankStatusGraveyard RankStatus = iota + -2
	// RankStatusWIP is a RankStatus of type WIP.
	RankStatusWIP
	// RankStatusPending is a RankStatus of type Pending.
	RankStatusPending
	// RankStatusRanked is a RankStatus of type Ranked.
	RankStatusRanked
	// RankStatusApproved is a RankStatus of type Approved.
	RankStatusApproved
	// RankStatusQualified is a RankStatus of type Qualified.
	RankStatusQualified
	// RankStatusLoved is a RankStatus of type Loved.
	RankStatusLoved
)

var ErrInvalidRankStatus = errors.New("not a valid RankStatus")

const _RankStatusName = "graveyardWIPpendingrankedapprovedqualifiedloved"

var _RankStatusMap = map[RankStatus]string{
	RankStatusGraveyard: _RankStatusName[0:9],
	RankStatusWIP:       _RankStatusName[9:12],
	RankStatusPending:   _RankStatusName[12:19],
	RankStatusRanked:    _RankStatusName[19:25],
	RankStatusApproved:  _RankStatusName[25:33],
	RankStatusQualified: _RankStatusName[33:42],
	RankStatusLoved:     _RankStatusName[42:47],
}

// String implements the Stringer interface.
func (x RankStatus) String() string {
	if str, ok := _RankStatusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("RankStatus(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x RankStatus) IsValid() bool {
	_, ok := _RankStatusMap[x]
	return ok
}

var _RankStatusValue = map[string]RankStatus{
	_RankStatusName[0:9]:   RankStatusGraveyard,
	_RankStatusName[9:12]:  RankStatusWIP,
	_RankStatusName[12:19]: RankStatusPending,
	_RankStatusName[19:25]: RankStatusRanked,
	_RankStatusName[25:33]: RankStatusApproved,
	_RankStatusName[33:42]: RankStatusQualified,
	_RankStatusName[42:47]: RankStatusLoved,
}

// ParseRankStatus attempts to convert a string to a RankStatus.
func ParseRankStatus(name string) (RankStatus, error) {
	if x, ok := _RankStatusValue[name]; ok {
		return x, nil
	}
	return RankStatus(0), fmt.Errorf("%s is %w", name, ErrInvalidRankStatus)
}

// MarshalText implements the text marshaller method.
func (x RankStatus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *RankStatus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseRankStatus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// RulesetOsu is a Ruleset of type Osu.
	RulesetOsu Ruleset = iota
	// RulesetTaiko is a Ruleset of type Taiko.
	RulesetTaiko
	// RulesetFruits is a Ruleset of type Fruits.
	RulesetFruits
	// RulesetMania is a Ruleset of type Mania.
	RulesetMania
)

var ErrInvalidRuleset = errors.New("not a valid Ruleset")

const _RulesetName = "osutaikofruitsmania"

var _RulesetMap = map[Ruleset]string{
	RulesetOsu:    _RulesetName[0:3],
	RulesetTaiko:  _RulesetName[3:8],
	RulesetFruits: _RulesetName[8:14],
	RulesetMania:  _RulesetName[14:19],
}

// String implements the Stringer interface.
func (x Ruleset) String() string {
	if str, ok := _RulesetMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Ruleset(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Ruleset) IsValid() bool {
	_, ok := _RulesetMap[x]
	return ok
}

var _RulesetValue = map[string]Ruleset{
	_RulesetName[0:3]:   RulesetOsu,
	_RulesetName[3:8]:   RulesetTaiko,
	_RulesetName[8:14]:  RulesetFruits,
	_RulesetName[14:19]: RulesetMania,
}

// ParseRuleset attempts to convert a string to a Ruleset.
func ParseRuleset(name string) (Ruleset, error) {
	if x, ok := _RulesetValue[name]; ok {
		return x, nil
	}
	return Ruleset(0), fmt.Errorf("%s is %w", name, ErrInvalidRuleset)
}

// MarshalText implements the text marshaller method.
func (x Ruleset) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Ruleset) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseRuleset(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
